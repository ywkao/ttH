#include "ScanChain_ttHLeptonic.h"

int ScanChain(TChain* chain, TString tag, TString year, TString ext, TString xml_file, TString bkg_options, bool doSyst = false, TString l1_prefire = "", TString mYear = "", TString idx = "", bool blind = true, bool fast = true, int nEvents = -1, string skimFilePrefix = "test") {
  //TFile* f1 = new TFile(tag + "_" + ext + "_histograms" + year + idx + ".root", "RECREATE");
  TFile* f1 = new TFile(tag + "_" + ext + "_histograms" + year + "_" + mYear + idx + ".root", "RECREATE");
  f1->cd();

  // Benchmark
  TBenchmark *bmark = new TBenchmark();
  bmark->Start("benchmark");

  bool evaluate_mva = xml_file != "none";

  // Make MVA Optimization Baby
  //OptimizationBabyMaker* baby = new OptimizationBabyMaker();
  TString xml_file_noExt = xml_file;
  xml_file_noExt.ReplaceAll(".xml", "");
  //TString optimization_baby_name = "Optimization/MVAOptimizationBaby_" + ext + "_" + xml_file_noExt + "_" + tag;
  //baby->MakeBabyNtuple( Form("%s.root", optimization_baby_name.Data()));

  // Create "process" objects
  vector<Process*> vProcess = generate_processes(f1);
  vector<TString> syst_labels = {};
  if (doSyst) {
    for (unsigned int i = 0; i < independent_systematic_collections.size(); i++) {
      syst_labels.push_back(independent_systematic_collections[i]);
    }
    for (unsigned int i = 0; i < weight_systematics.size(); i++) {
      syst_labels.push_back(weight_systematics[i]);
    }
  }

  if (doSyst)
    add_variables(vProcess, tag, syst_labels); // defined in ttHLooper 
  else
    add_variables(vProcess, tag);

  // Loop over events to Analyze
  unsigned int nEventsTotal = 0;
  unsigned int nEventsChain = chain->GetEntries();
  if (nEvents >= 0) nEventsChain = nEvents;
  TObjArray *listOfFiles = chain->GetListOfFiles();
  TIter fileIter(listOfFiles);
  TFile *currentFile = 0;

  // Initialize map of evt_run_lumi -> rand
  //RandomMap* rand_map = new RandomMap("Utils/random_map_Leptonic_" + ext + ".txt");

  TF1* photon_fakeID_shape = get_photon_ID_shape("fake");
  TF1* photon_fakeID_shape_runII = get_photon_ID_shape("fake_runII");

  // MVA Business
  unique_ptr<TMVA::Reader> mva;

  // Declare BDT vars
  float lep_pt_;
  float lep_eta_;

  float n_lep_loose_;
  float n_lep_medium_;
  float n_lep_tight_;

  float muon1_mini_iso_;
  float muon2_mini_iso_;

  float top_tag_score_;

  float maxIDMVA_;
  float minIDMVA_;
  float max2_bsum_;
  float max1_bsum_;
  float max2_btag_;
  float max1_btag_;
  float max2_ctag_;
  float max1_ctag_;
  float max1_cvsl_;
  float max2_cvsl_;
  float max1_cvsb_;
  float max2_cvsb_;
  float dipho_delta_R;
  float njets_;
  float nbjets_;
  float ht_;
  float lead_pT_;
  float sublead_pT_;
  float leadptoM_;
  float subleadptoM_;
  float leadIDMVA_;
  float subleadIDMVA_;
  float lead_eta_;
  float sublead_eta_;

  float jet1_pt_;
  float jet1_eta_;
  float jet1_btag_;
  float jet2_pt_;
  float jet2_eta_;
  float jet2_btag_;
  float jet3_pt_;
  float jet3_eta_;
  float jet3_btag_;
  float jet4_pt_;
  float jet4_eta_;
  float jet4_btag_;
  float jet5_pt_;
  float jet5_eta_;
  float jet5_btag_;
  float jet6_pt_;
  float jet6_eta_;
  float jet6_btag_;

  float leadPSV_;
  float subleadPSV_;

  float dipho_cosphi_;
  float dipho_rapidity_;
  float dipho_pt_;
  float met_;

  float dipho_pt_over_mass_;
  float helicity_angle_;


  if (evaluate_mva) {
    mva.reset(new TMVA::Reader( "!Color:Silent" ));
    mva->AddVariable("maxIDMVA_", &maxIDMVA_);
    mva->AddVariable("minIDMVA_", &minIDMVA_);
    mva->AddVariable("max2_btag_", &max2_btag_);
    mva->AddVariable("max1_btag_", &max1_btag_);
    mva->AddVariable("dipho_delta_R", &dipho_delta_R);
    mva->AddVariable("njets_", &njets_);
    //mva->AddVariable("nbjets_", &nbjets_);
    mva->AddVariable("ht_", &ht_);
    mva->AddVariable("leadptoM_", &leadptoM_);
    mva->AddVariable("subleadptoM_", &subleadptoM_);
    //mva->AddVariable("leadIDMVA_", &leadIDMVA_);
    //mva->AddVariable("subleadIDMVA_", &subleadIDMVA_); 
    mva->AddVariable("lead_eta_", &lead_eta_);
    mva->AddVariable("sublead_eta_", &sublead_eta_);

    mva->AddVariable("jet1_pt_", &jet1_pt_);
    mva->AddVariable("jet1_eta_", &jet1_eta_);
    mva->AddVariable("jet1_btag_", &jet1_btag_);
    mva->AddVariable("jet2_pt_", &jet2_pt_);
    mva->AddVariable("jet2_eta_", &jet2_eta_);
    mva->AddVariable("jet2_btag_", &jet2_btag_);
    mva->AddVariable("jet3_pt_", &jet3_pt_);
    mva->AddVariable("jet3_eta_", &jet3_eta_);
    mva->AddVariable("jet3_btag_", &jet3_btag_);
    mva->AddVariable("jet4_pt_", &jet4_pt_);
    mva->AddVariable("jet4_eta_", &jet4_eta_);
    mva->AddVariable("jet4_btag_", &jet4_btag_);
    //mva->AddVariable("jet5_pt_", &jet5_pt_);
    //mva->AddVariable("jet5_eta_", &jet5_eta_);
    //mva->AddVariable("jet5_btag_", &jet5_btag_);
    //mva->AddVariable("jet6_pt_", &jet6_pt_);
    //mva->AddVariable("jet6_eta_", &jet6_eta_);
    //mva->AddVariable("jet6_btag_", &jet6_btag_);

    mva->AddVariable("leadPSV_", &leadPSV_);
    mva->AddVariable("subleadPSV_", &subleadPSV_);

    mva->AddVariable("dipho_cosphi_", &dipho_cosphi_);
    mva->AddVariable("dipho_rapidity_", &dipho_rapidity_);
    mva->AddVariable("met_", &met_);

    //mva->AddVariable("top_tag_score_", &top_tag_score_);
    
    mva->AddVariable("dipho_pt_over_mass_", &dipho_pt_over_mass_);
    mva->AddVariable("helicity_angle_", &helicity_angle_);

    mva->AddVariable("lep_pt_", &lep_pt_);
    mva->AddVariable("lep_eta_", &lep_eta_);

    //mva->AddVariable("n_lep_loose_", &n_lep_loose_);
    //mva->AddVariable("n_lep_medium_", &n_lep_medium_);
    mva->AddVariable("n_lep_tight_", &n_lep_tight_);

    //mva->AddVariable("muon1_mini_iso_", &muon1_mini_iso_);
    //mva->AddVariable("muon2_mini_iso_", &muon2_mini_iso_);

    mva->BookMVA("BDT", xml_file);
  }

  float bJet_Pt;
  float bJet_Eta;
  float bJet_btag;
  float M1Jet_Pt;
  float M1Jet_Eta;
  float M1Jet_btag;
  float lep_ID;
  float lep_Pt;
  float lep_Eta;
  float M1;
  float dR_qH;
  float dR_lb;
  float dR_lt;
  float dR_lH;
  float dPhi_bMET;
  float Met_Pt;

  TString dir_nn;

  unique_ptr<TMVA::Reader> reader_tt_v2; //do_meng_cheng_top_reco_mva
  unique_ptr<TMVA::Reader> reader_st_v2; //do_meng_cheng_top_reco_mva
  dir_nn = "/wk_cms2/ykao/CMSSW_9_4_10/src/ttH/Loopers/fcncTagger";
  //bool do_reader_tt_v2 = true;{{{
  bool do_reader_tt_v2 = true;
  if (do_reader_tt_v2) {
    reader_tt_v2.reset(new TMVA::Reader( "!Color:Silent" ));

	// Set discriminating variables
	reader_tt_v2->AddVariable("bJet_Pt", &bJet_Pt);
	reader_tt_v2->AddVariable("bJet_Eta", &bJet_Eta);
	reader_tt_v2->AddVariable("bJet_btag", &bJet_btag);
	reader_tt_v2->AddVariable("M1Jet_Pt", &M1Jet_Pt);
	reader_tt_v2->AddVariable("M1Jet_Eta", &M1Jet_Eta);
	reader_tt_v2->AddVariable("M1Jet_btag", &M1Jet_btag);
	reader_tt_v2->AddVariable("lep_ID", &lep_ID);
	reader_tt_v2->AddVariable("lep_Pt", &lep_Pt);
	reader_tt_v2->AddVariable("lep_Eta", &lep_Eta);
	reader_tt_v2->AddVariable("M1", &M1);
	reader_tt_v2->AddVariable("dR_qH", &dR_qH);
	reader_tt_v2->AddVariable("dR_lb", &dR_lb);
	reader_tt_v2->AddVariable("dR_lt", &dR_lt);
	reader_tt_v2->AddVariable("dPhi_bMET", &dPhi_bMET);
	reader_tt_v2->AddVariable("Met_Pt", &Met_Pt);
	// Book MVA methods
	reader_tt_v2->BookMVA("TT_lep_MVA", dir_nn + "/TTlep_ANN_v3.weights.xml");
  }
  //}}}
  //bool do_reader_st_v2 = true;{{{
  bool do_reader_st_v2 = true;
  if (do_reader_st_v2) {
    reader_st_v2.reset(new TMVA::Reader( "!Color:Silent" ));

	// Set discriminating variables
	reader_st_v2->AddVariable("bJet_Pt", &bJet_Pt);
	reader_st_v2->AddVariable("bJet_Eta", &bJet_Eta);
	reader_st_v2->AddVariable("bJet_btag", &bJet_btag);
	reader_st_v2->AddVariable("lep_ID", &lep_ID);
	reader_st_v2->AddVariable("lep_Pt", &lep_Pt);
	reader_st_v2->AddVariable("lep_Eta", &lep_Eta);
	reader_st_v2->AddVariable("dR_lb", &dR_lb);
	reader_st_v2->AddVariable("dR_lH", &dR_lH);
	reader_st_v2->AddVariable("dPhi_bMET", &dPhi_bMET);
	reader_st_v2->AddVariable("Met_Pt", &Met_Pt);
	// Book MVA methods
	reader_st_v2->BookMVA("ST_lep_MVA", dir_nn + "/STlep_ANN_v3.weights.xml");
  }
  //}}}

  unique_ptr<TMVA::Reader> reader_tt_v4; //do_meng_cheng_top_reco_mva
  unique_ptr<TMVA::Reader> reader_st_v4; //do_meng_cheng_top_reco_mva
  dir_nn = "/wk_cms2/mc_cheng/public/tqHGG/2017_DeepJet/MVAreco_model/dataset/weights";
  //bool do_reader_tt_v4 = true;{{{
  bool do_reader_tt_v4 = true;
  if (do_reader_tt_v4) {
    reader_tt_v4.reset(new TMVA::Reader( "!Color:Silent" ));

	// Set discriminating variables
	reader_tt_v4->AddVariable("bJet_Pt", &bJet_Pt);
	reader_tt_v4->AddVariable("bJet_Eta", &bJet_Eta);
	reader_tt_v4->AddVariable("bJet_btag", &bJet_btag);
	reader_tt_v4->AddVariable("M1Jet_Pt", &M1Jet_Pt);
	reader_tt_v4->AddVariable("M1Jet_Eta", &M1Jet_Eta);
	reader_tt_v4->AddVariable("M1Jet_btag", &M1Jet_btag);
	reader_tt_v4->AddVariable("lep_ID", &lep_ID);
	reader_tt_v4->AddVariable("lep_Pt", &lep_Pt);
	reader_tt_v4->AddVariable("lep_Eta", &lep_Eta);
	reader_tt_v4->AddVariable("M1", &M1);
	reader_tt_v4->AddVariable("dR_qH", &dR_qH);
	reader_tt_v4->AddVariable("dR_lb", &dR_lb);
	reader_tt_v4->AddVariable("dR_lt", &dR_lt);
	reader_tt_v4->AddVariable("dPhi_bMET", &dPhi_bMET);
	reader_tt_v4->AddVariable("Met_Pt", &Met_Pt);
	// Book MVA methods
	reader_tt_v4->BookMVA("TT_lep_MVA", dir_nn + "/TTlep_ANN.weights.xml");
  }
  //}}}
  //bool do_reader_st_v4 = true;{{{
  bool do_reader_st_v4 = true;
  if (do_reader_st_v4) {
    reader_st_v4.reset(new TMVA::Reader( "!Color:Silent" ));

	// Set discriminating variables
	reader_st_v4->AddVariable("bJet_Pt", &bJet_Pt);
	reader_st_v4->AddVariable("bJet_Eta", &bJet_Eta);
	reader_st_v4->AddVariable("bJet_btag", &bJet_btag);
	reader_st_v4->AddVariable("lep_ID", &lep_ID);
	reader_st_v4->AddVariable("lep_Pt", &lep_Pt);
	reader_st_v4->AddVariable("lep_Eta", &lep_Eta);
	reader_st_v4->AddVariable("dR_lb", &dR_lb);
	reader_st_v4->AddVariable("dR_lH", &dR_lH);
	reader_st_v4->AddVariable("dPhi_bMET", &dPhi_bMET);
	reader_st_v4->AddVariable("Met_Pt", &Met_Pt);
	// Book MVA methods
	reader_st_v4->BookMVA("ST_lep_MVA", dir_nn + "/STlep_ANN.weights.xml");
  }
  //}}}

  double w_gamma_yield = 0;

  // File Loop
  bool apply_ctag_reshaping = true;
  //std::string root_file_deepJet = "/wk_cms2/ykao/CMSSW_9_4_10/src/ttH/Loopers/ctag_reshaping/sfs_rootfiles/DeepJet_ctagSF_MiniAOD94X_2017_pTincl.root";
  //std::string root_file_deepJet_17 = "/wk_cms2/ykao/CMSSW_9_4_10/src/ttH/Loopers/ctag_reshaping/sfs_rootfiles/DeepJet_ctagSF_MiniAOD94X_2017_pTincl-PUIDLoose-PRELIMINARY.root";
  std::string root_file_deepJet_17 = "/wk_cms2/ykao/CMSSW_9_4_10/src/ttH/Loopers/ctag_reshaping/sfs_rootfiles/DeepJet_ctagSF_MiniAOD94X_2017_pTincl_v2.root";
  std::string root_file_deepJet_18 = "/wk_cms2/ykao/CMSSW_9_4_10/src/ttH/Loopers/ctag_reshaping/sfs_rootfiles/DeepJet_ctagSF_MiniAOD102X_2018_pTincl.root"; //2018
  std::string root_file_deepJet_16 = "/wk_cms2/ykao/CMSSW_9_4_10/src/ttH/Loopers/ctag_reshaping/sfs_rootfiles/DeepJet_ctagSF_MiniAOD94X_2016_pTincl_01Nov20.root"; //2016
  //std::string root_file_deepJet_16 = "/wk_cms2/ykao/CMSSW_9_4_10/src/ttH/Loopers/ctag_reshaping/sfs_rootfiles/DeepCSV_cTag_SFs_80X_Incl_pt20_BTV_6Mar_Extended.root"; //2016
  //std::string root_file_deepJet_16 = "/wk_cms2/ykao/CMSSW_9_4_10/src/ttH/Loopers/ctag_reshaping/sfs_rootfiles/DeepJet_ctagSF_MiniAOD94X_2017_pTincl-PUIDLoose-PRELIMINARY.root"; //2016
  std::string root_file_deepJet = (mYear == "2016") ? root_file_deepJet_16 : ((mYear == "2017") ? root_file_deepJet_17 : root_file_deepJet_18 );

  retrieve_scale_factor sf(root_file_deepJet);
  while ( (currentFile = (TFile*)fileIter.Next()) ) {

    // Get File Content
    TString currentFileTitle = currentFile->GetTitle();
    cout << currentFileTitle << endl;
    TFile file(currentFileTitle);

    /*
    TTree *tree;
    if (currentFileTitle.Contains("v4."))
        tree = (TTree*)file.Get("tagsDumper/trees/_13TeV_TTHLeptonicTag");
    else
        tree = (TTree*)file.Get("tthLeptonicTagDumper/trees/tth_13TeV_all"); 
    if (fast) TTreeCache::SetLearnEntries(10);
    if (fast) tree->SetCacheSize(128*1024*1024);
    cms3.Init(tree);
    */

    // Skip Pythia GJets
    if (currentFileTitle.Contains("GJet_Pt")) {
      cout << "Skipping Pythia GJets sample: " << currentFileTitle << endl;
      continue;
    }

    // Decide what type of sample this is
    bool isData = currentFileTitle.Contains("DoubleEG") || currentFileTitle.Contains("EGamma");
    bool isSignal = currentFileTitle.Contains("ttHJetToGG") || currentFileTitle.Contains("ttHToGG") || currentFileTitle.Contains("THQ") || currentFileTitle.Contains("THW") || currentFileTitle.Contains("VBF") || currentFileTitle.Contains("GluGluHToGG") || currentFileTitle.Contains("VHToGG") || currentFileTitle.Contains("FCNC");
    if (mYear == "")
      mYear = (currentFileTitle.Contains("Run2016") || currentFileTitle.Contains("RunIISummer16")) ? "2016" : ((currentFileTitle.Contains("Run2017") || currentFileTitle.Contains("RunIIFall17")) ? "2017" : ((currentFileTitle.Contains("Run2018") || currentFileTitle.Contains("RunIIAutumn18")) ? "2018" : "no_year")); 

    if (isSignal) {
      if (categorize_signal_sample(currentFileTitle) != 0 && !currentFileTitle.Contains("FCNC"))
        continue;
      if ((currentFileTitle.Contains("M120") || currentFileTitle.Contains("M130")) && !currentFileTitle.Contains("FCNC"))
        continue; 
    }

    if (is_wrong_tt_jets_sample(currentFileTitle, "Leptonic"))                        continue;
    if (bkg_options.Contains("impute") && (currentFileTitle.Contains("GJets_HT") || currentFileTitle.Contains("QCD"))) {
      cout << "Skipping this sample: " << currentFileTitle << ", since we are imputing." << endl;
      continue;
    }

    /*
    // Dumb hacky stuff to use 2017 MC as placeholders for 2018
    if (already_looped_dipho && currentFileTitle.Contains("DiPhotonJetsBox"))
      mYear = "2018";
    if (already_looped_qcd && currentFileTitle.Contains("QCD"))
      mYear = "2018";
    if (already_looped_dy && currentFileTitle.Contains("DYJetsToLL_M-50_TuneCP5_13TeV-amcatnloFXFX"))
      mYear = "2018";

    if (currentFileTitle.Contains("DiPhotonJetsBox_MGG-80toInf_13TeV-Sherpa_RunIIFall17MiniAODv2"))
      already_looped_dipho = true;
    if (currentFileTitle.Contains("QCD_Pt-40toInf_DoubleEMEnriched_MGG-80toInf_TuneCP5_13TeV_Pythia8_RunIIFall17MiniAODv2-PU2017_12Apr2018_94X_mc2017_realistic_v14-v1_MINIAODSIM"))
      already_looped_qcd = true;
    if (currentFileTitle.Contains("DYJetsToLL_M-50_TuneCP5_13TeV-amcatnloFXFX-pythia8_RunIIFall17MiniAODv2-PU2017_12Apr2018_new_pmx_94X_mc2017_realistic_v14_ext1-v1_MINIAODSIM"))
      already_looped_dy = true;
    */

    cout << "mYear: " << mYear << endl;
    int yearId = mYear == "2016" ? 0 : (mYear == "2017" ? 1 : (mYear == "2018" ? 2 : -1)); 

    // Set json file
    set_json(mYear);

    double btag_norm_correction = 1.;
    double ctag_norm_correction = 1.;

    // Loop over each tree
    for (unsigned int i = 0; i < independent_systematic_collections.size(); i++) {
        if ((isData || !doSyst) && i >= 1)
            continue;

        TString syst_ext = independent_systematic_collections[i];
        std::vector<TString> weight_systs = {""};
        if (syst_ext == "" && doSyst && !isData) {
            for (unsigned int j = 0; j < weight_systematics.size(); j++)
                weight_systs.push_back(weight_systematics[j]);
        }

        if (syst_ext != "")
            syst_ext = "_" + syst_ext;

        // Loop over each syst weight
        for (unsigned int j = 0; j < weight_systs.size(); j++) {
            syst_ext = independent_systematic_collections[i];
            if (syst_ext != "")
                syst_ext = "_" + syst_ext;
            TTree *tree; 
            if ( (currentFileTitle.Contains("v4.") && !currentFileTitle.Contains("FCNC")) || currentFileTitle.Contains("v5."))
            {
                cout << "Grabbing this tree: " << "tagsDumper/trees/_13TeV_TTHLeptonicTag" + syst_ext << endl;
                tree = (TTree*)file.Get("tagsDumper/trees/_13TeV_TTHLeptonicTag" + syst_ext);
            }
            else {
                cout << "Grabbing this tree: tthLeptonicTagDumper/trees/tth_13TeV_all" << endl;
                tree = (TTree*)file.Get("tthLeptonicTagDumper/trees/tth_13TeV_all");
            }
            if (fast) tree->SetCacheSize(128*1024*1024);
            cms3.Init(tree);

            syst_ext = independent_systematic_collections[i] + weight_systs[j];

            cout << "Looping over syst tree " << i << ", weight syst " << j << ", with syst label: " << syst_ext << endl;

            // Loop over Events in current file
            //if (nEventsTotal >= nEventsChain) continue;
            unsigned int nEventsTree = tree->GetEntriesFast();
            nEventsChain = nEventsTree;
            nEventsTotal = 0;

            if (!isData && btag_norm_correction == 1.) {
                double integral_no_btag = 0.;
                double integral_w_btag =  0.;
                for (unsigned int event = 0; event < nEventsTree; ++event) {
                    if (fast) tree->LoadTree(event);
                    cms3.GetEntry(event);
                    ++nEventsTotal;

                    ttHLeptonic::progress( nEventsTotal, nEventsChain );

                    if (!passes_btag_rescale_selection())       continue;

                    double weight_no_btag = weight() / weight_JetBTagWeight();

                    if (!(isnan(weight_no_btag) || isinf(weight_no_btag))) {
                        integral_no_btag += weight_no_btag;
                        integral_w_btag += weight();
                    }
                }
                btag_norm_correction = integral_no_btag / integral_w_btag;
                cout << "btag_normalization_factor: " << btag_norm_correction << endl;
            }

            //--------------------- c-tag reshaping ---------------------//
            nEventsTotal = 0;
            if (!isData) {
                double integral_no_ctag = 0.;
                double integral_w_ctag =  0.;
                //for (unsigned int event = 0; event < 100; ++event) {
                for (unsigned int event = 0; event < nEventsTree; ++event) {
                    if (fast) tree->LoadTree(event);
                    cms3.GetEntry(event);
                    ++nEventsTotal;

                    ttHLeptonic::progress( nEventsTotal, nEventsChain );

                    if (!passes_btag_rescale_selection())       continue; // n_jets() < 3 continue

                    /* Note: c-tag has not been applied to the central weight */
                    double weight_JetCTagWeight = get_ctag_reshaping_weight(mYear, sf);
                    double weight_no_ctag = weight();
                    double weight_with_ctag = weight() * weight_JetCTagWeight;

                    if (!(isnan(weight_no_ctag) || isinf(weight_no_ctag))) {
                        integral_no_ctag += weight_no_ctag;
                        integral_w_ctag += weight_with_ctag;
                        //std::cout << event << " weight = " << weight() << std::endl;
                        //std::cout << "weight_JetCTagWeight = " << weight_JetCTagWeight << std::endl;
                        //std::cout << "weight_no_ctag = " << weight_no_ctag << std::endl;
                        //std::cout << "weight_with_ctag = " << weight_with_ctag << std::endl;
                    }
                }
                ctag_norm_correction = integral_no_ctag / integral_w_ctag;
                cout << "ctag_normalization_factor: " << ctag_norm_correction << endl;
              }
            //--------------------- end of c-tag reshaping ---------------------//

            nEventsTotal = 0; 

            for (unsigned int event = 0; event < nEventsTree; ++event) {

              // Get Event Content
              //if (nEventsTotal >= nEventsChain) continue;
              if (fast) tree->LoadTree(event);
              cms3.GetEntry(event);
              ++nEventsTotal;

              // Progress
              ttHLeptonic::progress( nEventsTotal, nEventsChain );

              // Check golden json
              if (isData) {
                if (!pass_json(mYear, cms3.run(), cms3.lumi()))		continue;
              }


              // Fill mva baby before any selections
              int genPhotonId = isData ? -1 : categorize_photons(leadGenMatch(), subleadGenMatch());
              int processId = categorize_process(currentFileTitle, genPhotonId);
              if (processId == 17)
                processId = 3; // use Madgraph GJets instead of Pythia

              int genLeptonId = isData ? -1 : categorize_leptons(nGoodEls(), nGoodMus());
              int genPhotonDetailId = isData ? -1 : categorize_photons_detail(lead_photon_type(), sublead_photon_type());
              int photonLocationId = categorize_photon_locations(leadEta(), subleadEta());

              float evt_weight = 1.;
             
              //--- Apply c-tag reshaping method ---//
              double weight_decided = 1.;
              if(!isData)
              {
                double weight_JetCTagWeight = get_ctag_reshaping_weight(mYear, sf);
                double weight_no_ctag = weight() / weight_JetBTagWeight(); // revmove default applied b-tag reshaping
                double weight_with_ctag = weight_no_ctag * weight_JetCTagWeight;
                weight_decided = (apply_ctag_reshaping) ? weight_with_ctag : weight_no_ctag;

                evt_weight /= btag_norm_correction; // revmove default applied b-tag reshaping
                if(apply_ctag_reshaping) evt_weight *= ctag_norm_correction;
              }

              //printf("weight: %.3f\n", weight());
              //printf("weight without b-tag: %.3f (sf = %.3f)\n", weight_no_ctag, weight_JetBTagWeight());
              //printf("weight with c-tag   : %.3f (sf = %.3f)\n", weight_with_ctag, weight_JetCTagWeight);
              //printf("\n");

              if (year.Contains("RunII") && !isData) {
            double scale1fb = currentFileTitle.Contains("RunIISummer16MiniAOD") ? scale1fb_2016_RunII(currentFileTitle) : ( currentFileTitle.Contains("RunIIFall17MiniAOD") ? scale1fb_2017_RunII(currentFileTitle) : ( currentFileTitle.Contains("RunIIAutumn18MiniAOD") ? scale1fb_2018_RunII(currentFileTitle) : 0 ));
            if (mYear == "2016")
              evt_weight *= scale1fb * lumi_2016 * weight_decided;
            else if (mYear == "2017")
              evt_weight *= scale1fb * lumi_2017 * weight_decided;
            else if (mYear == "2018")
                  evt_weight *= scale1fb * lumi_2018 * weight_decided;
              }	

              else if (!isData) {
                if (year == "2018") // temporary hack to use 2017 mc with 2018 data
                  evt_weight *= scale1fb_2017(currentFileTitle) * lumi_2018 * weight_decided;
                else if (mYear == "2016")
                  evt_weight *= scale1fb_2016(currentFileTitle) * lumi_2016 * weight_decided;
                else if (mYear == "2017") 
                  evt_weight *= scale1fb_2017(currentFileTitle) * lumi_2017 * weight_decided;
                else if (mYear == "2018")
                  evt_weight *= scale1fb_2017(currentFileTitle) * lumi_2018 * weight_decided;
              }

              bool pu_weight = true;
              if (pu_weight) {
            evt_weight *= puweight();
              }
              if (isnan(evt_weight) || isinf(evt_weight) || evt_weight == 0) {
            continue; //some pu weights are nan/inf and this causes problems for histos 
              }

              if (l1_prefire != "" && !isData && mYear != "2018") {
                //cout << "Prefire prob: " << prefireProbability() << endl;
                //cout << "Undoing L1 prefire prob: " << 1. / (1. - prefireProbability()) << endl;
                //cout << "Varying L1 prefire up: "   << (1. - (prefireProbability()*1.2)) << endl;
                //cout << "Varying L1 prefire down: " << (1. - (prefireProbability()*0.8)) << endl;
                evt_weight *= 1. / (1. - prefireProbability()); // undo
                if (l1_prefire == "up")
                    evt_weight *= (1. - (prefireProbability()*1.2));
                else if (l1_prefire == "down")
                    evt_weight *= (1. - (prefireProbability()*0.8));
              }

              int label = isData ? 2 : (isSignal ? 1 : 0); // 0 = bkg, 1 = signal, 2 = data


              // Modify weight for systematics affecting weights
              if (j >= 1) {
                double nominal_weight, up_variation, down_variation;
                if (syst_ext.Contains("UnmatchedPUWeight")) {
                  nominal_weight = (UnmatchedPUWeightUp01sigma() + UnmatchedPUWeightDown01sigma())/2.;
                  up_variation = UnmatchedPUWeightUp01sigma() / nominal_weight;
                  down_variation = UnmatchedPUWeightDown01sigma() / nominal_weight;
                }
                else if (syst_ext.Contains("MvaLinearSyst")) {
                  nominal_weight = (MvaLinearSystUp01sigma() + MvaLinearSystDown01sigma())/2.;
                  up_variation = MvaLinearSystUp01sigma() / nominal_weight;
                  down_variation = MvaLinearSystDown01sigma() / nominal_weight;
                }
                else if (syst_ext.Contains("LooseMvaSF")) {
                  nominal_weight = (LooseMvaSFUp01sigma() + LooseMvaSFDown01sigma())/2.;
                  up_variation = LooseMvaSFUp01sigma() / nominal_weight;
                  down_variation = LooseMvaSFDown01sigma() / nominal_weight;
                }
                else if (syst_ext.Contains("PreselSF")) {
                  nominal_weight = (PreselSFUp01sigma() + PreselSFDown01sigma())/2.;
                  up_variation = PreselSFUp01sigma() / nominal_weight;
                  down_variation = PreselSFDown01sigma() / nominal_weight;
                }
                else if (syst_ext.Contains("electronVetoSF")) {
                  nominal_weight = (electronVetoSFUp01sigma() + electronVetoSFDown01sigma())/2.;
                  up_variation = electronVetoSFUp01sigma() / nominal_weight;
                  down_variation = electronVetoSFDown01sigma() / nominal_weight;
                }
                else if (syst_ext.Contains("TriggerWeight")) {
                  nominal_weight = (TriggerWeightUp01sigma() + TriggerWeightDown01sigma())/2.;
                  up_variation = TriggerWeightUp01sigma() / nominal_weight;
                  down_variation = TriggerWeightDown01sigma() / nominal_weight;
                }
                else if (syst_ext.Contains("FracRVWeight")) {
                  nominal_weight = (FracRVWeightUp01sigma() + FracRVWeightDown01sigma())/2.;
                  up_variation = FracRVWeightUp01sigma() / nominal_weight;
                  down_variation = FracRVWeightDown01sigma() / nominal_weight;
                }
                else if (syst_ext.Contains("ElectronWeight")) {
                  nominal_weight = (ElectronWeightUp01sigma() + ElectronWeightDown01sigma())/2.;
                  up_variation = ElectronWeightUp01sigma() / nominal_weight;
                  down_variation = ElectronWeightDown01sigma() / nominal_weight;
                }
                else if (syst_ext.Contains("JetBTagCutWeight")) {
                  nominal_weight = (JetBTagCutWeightUp01sigma() + JetBTagCutWeightDown01sigma())/2.;
                  up_variation = JetBTagCutWeightUp01sigma() / nominal_weight;
                  down_variation = JetBTagCutWeightDown01sigma() / nominal_weight;
                }
                else if (syst_ext.Contains("JetBTagReshapeWeight")) {
                  nominal_weight = (JetBTagReshapeWeightUp01sigma() + JetBTagReshapeWeightDown01sigma())/2.;
                  up_variation = JetBTagReshapeWeightUp01sigma() / nominal_weight;
                  down_variation = JetBTagReshapeWeightDown01sigma() / nominal_weight;
                }

                if (syst_ext.Contains("Up01sigma"))
                    evt_weight *= up_variation;
                else if (syst_ext.Contains("Down01sigma"))
                    evt_weight *= down_variation;
              }


              // Make p4 for physics objects
              vector<TLorentzVector> jets;
              vector<double> btag_scores;
              vector<std::pair<int, double>> btag_scores_sorted;
              TLorentzVector lead_photon;
              TLorentzVector sublead_photon;
              vector<TLorentzVector> electrons;
              vector<TLorentzVector> muons;
              vector<TLorentzVector> leps;
              vector<TLorentzVector> leps_unordered;
              jets = make_jets(btag_scores, year);
              btag_scores_sorted = sortVector(btag_scores);
              lead_photon = make_lead_photon();
              sublead_photon = make_sublead_photon();
              electrons = make_els();
              muons = make_mus();
              leps = make_leps(electrons, muons);
              leps_unordered = make_leps_unordered(electrons, muons);
              // WARNING: the charges are assigned randomly for testing purpose!!
              vector<float> electron_charges;
              vector<float> muon_charges;
              vector<float> lep_charges; // for meng-cheng's method
              electron_charges = make_els_charges();
              muon_charges = make_mus_charges();
              lep_charges = make_lep_charges(electron_charges, muon_charges);
              TLorentzVector diphoton = lead_photon + sublead_photon;
              vector<TLorentzVector> objects;
              for (int i = 0; i < jets.size(); i++)
                objects.push_back(jets[i]);
              for (int i = 0; i < leps.size(); i++)
                objects.push_back(leps[i]);

              int recoLeptonId = categorize_reco_leptons(electrons.size(), muons.size());

              double mva_value = -999;

              lep_pt_ = leps[0].Pt();
              lep_eta_ = leps[0].Eta();

              n_lep_loose_ = nElecLoose() + nMuonLoose();
              n_lep_medium_ = nElecMedium() + nMuonMedium();
              n_lep_tight_ = nElecTight() + nMuonTight();

              muon1_mini_iso_ = muon1_pt() > 0 ? muonLeadIso() / muon1_pt() : -999;
              muon2_mini_iso_ = muon2_pt() > 0 ? muonSubleadIso() / muon2_pt() : -999;

              top_tag_score_ = -1;
              //top_tag_score_ = topTag_score();

              maxIDMVA_ = leadIDMVA() > subleadIDMVA() ? leadIDMVA() : subleadIDMVA();
              minIDMVA_ = leadIDMVA() <= subleadIDMVA() ? leadIDMVA() : subleadIDMVA();

              // Impute, if applicable
              if (bkg_options.Contains("impute")) {
                if (isData)
                  impute_photon_and_lepton_id(min_photon_ID_presel_cut, maxIDMVA_, photon_fakeID_shape_runII, minIDMVA_, n_lep_medium_, n_lep_tight_, evt_weight, processId);
              }

              // Scale bkg weight
              evt_weight *= scale_bkg(currentFileTitle, bkg_options, processId, "Leptonic");

              // Scale FCNC to current best observed limit (ATLAS 2016 combination)
              if (currentFileTitle.Contains("FCNC"))
                evt_weight *= scale_fcnc(currentFileTitle);

              if (currentFileTitle.Contains("FCNC"))
                evt_weight *= scale_fcnc_to_atlas_limit(currentFileTitle);

              // Blinded region 
              if (isData && processId != 18 && blind && mass() > 120 && mass() < 130)        continue;

              if (bkg_options == "old_vgamma") {
              if (has_ttX_overlap(currentFileTitle, lead_Prompt(), sublead_Prompt()))	continue;
              if (has_simple_qcd_overlap(currentFileTitle, genPhotonId))		continue;
              if (currentFileTitle.Contains("ZGTo2LG") || currentFileTitle.Contains("ZGToLLG"))	continue;
              if (currentFileTitle.Contains("DYJetsToLL") && genPhotonId >= 1)
                processId = 7; 
              }	
              else
                if (has_std_overlaps(currentFileTitle, lead_Prompt(), sublead_Prompt(), genPhotonId))     continue;

              //--------------------- max c-tag ---------------------//

              max1_bsum_ = 0.;
              max2_bsum_ = 0.;
              max1_btag_ = 0.;
              max2_btag_ = 0.;
              max1_ctag_ = 0.;
              max2_ctag_ = 0.;
              max1_cvsl_ = 0.;
              max2_cvsl_ = 0.;
              max1_cvsb_ = 0.;
              max2_cvsb_ = 0.;

              retrieve_max_discriminants(max1_bsum_, max2_bsum_, max1_btag_, max2_btag_, max1_ctag_, max2_ctag_, max1_cvsl_, max2_cvsl_, max1_cvsb_, max2_cvsb_);

              //--------------------- end of max c-tag ---------------------//
              
              dipho_delta_R = lead_photon.DeltaR(sublead_photon);
              ht_ = get_ht(jets);
              njets_ = n_jets();
              nbjets_ = nb_medium();

              jet1_pt_   = njets_ >= 1 ? jets[0].Pt()   : -999;
              jet1_eta_  = njets_ >= 1 ? jets[0].Eta()  : -999;
              jet1_btag_ = njets_ >= 1 ? btag_scores[0] : -999;
              jet2_pt_   = njets_ >= 2 ? jets[1].Pt()   : -999;
              jet2_eta_  = njets_ >= 2 ? jets[1].Eta()  : -999;
              jet2_btag_ = njets_ >= 2 ? btag_scores[1] : -999;
              jet3_pt_   = njets_ >= 3 ? jets[2].Pt()   : -999;
              jet3_eta_  = njets_ >= 3 ? jets[2].Eta()  : -999;
              jet3_btag_ = njets_ >= 3 ? btag_scores[2] : -999;
              jet4_pt_   = njets_ >= 4 ? jets[3].Pt()   : -999;
              jet4_eta_  = njets_ >= 4 ? jets[3].Eta()  : -999;
              jet4_btag_ = njets_ >= 4 ? btag_scores[3] : -999;
              jet5_pt_   = njets_ >= 5 ? jets[4].Pt()   : -999;
              jet5_eta_  = njets_ >= 5 ? jets[4].Eta()  : -999;
              jet5_btag_ = njets_ >= 5 ? btag_scores[4] : -999;
              jet6_pt_   = njets_ >= 6 ? jets[5].Pt()   : -999;
              jet6_eta_  = njets_ >= 6 ? jets[5].Eta()  : -999;
              jet6_btag_ = njets_ >= 6 ? btag_scores[5] : -999;

              lead_pT_ = leadPt();
              sublead_pT_ = subleadPt();
              leadptoM_ = lead_ptoM();
              subleadptoM_ = sublead_ptoM();
              leadIDMVA_ = leadIDMVA();
              subleadIDMVA_ = subleadIDMVA();
              lead_eta_ = leadEta();
              sublead_eta_ = subleadEta();

              leadPSV_ = leadPixelSeed();
              subleadPSV_ = subleadPixelSeed();

              dipho_cosphi_ = dipho_cosphi();
              dipho_rapidity_ = dipho_rapidity();
              dipho_pt_ = diphoton.Pt();
              met_ = MetPt();
              //met_ = -1;

              dipho_pt_over_mass_ = diphoton.Pt() / mass();
              helicity_angle_ = helicity(lead_photon, sublead_photon);

              if (evaluate_mva) {
                mva_value = convert_tmva_to_prob(mva->EvaluateMVA( "BDT" ));
              }

              float m_gl_lead = (leps[0] + lead_photon).M();
              float m_gl_sublead = (leps[0] + sublead_photon).M(); 


              if (!passes_selection(tag, minIDMVA_, maxIDMVA_, n_lep_medium_, n_lep_tight_, mva_value, m_gl_lead, m_gl_sublead)) continue;
              int mvaCategoryId = mva_value < -0.8 ? 0 : 1;

              vector<int> vId = {genLeptonId, genPhotonId, genPhotonDetailId, photonLocationId, mvaCategoryId, recoLeptonId, yearId}; 



              //----- Meng-Cheng's method -----//
              int nleps_ = leps.size();
              float met_phi_ = MetPhi();
              TLorentzVector reco_H = diphoton;
              // determine jet candidates according to permutations with MVA scores
              float mc_mva_score_tt_v2_;
              float mc_mva_score_st_v2_;
              // nested for loops for the MVA score, mc_mva_score_tt_v2_ {{{
              do_reader_tt_v2 = (njets_ >= 2) and (nleps_ >= 1);
              if(do_reader_tt_v2) {
                int perm = -1;
                int best_perm = -1;
                double best_score = -999;
                vector<int> best_indices = {-1, -1, -1};
                vector<vector<int>> indices_collector;
        
                // Start b-jet loop
                for (int i=0; i<njets_; ++i) {
                	// Start fcnc jet loop
                	for (int j=0; j<njets_; ++j) {
                		if (j == i) continue;
                		// Start lep loop
                		for (int k=0; k<nleps_; ++k) {
        
                            bJet_Pt = jets[i].Pt();
                            bJet_Eta = jets[i].Eta();
                            bJet_btag = btag_scores[i];
                            M1Jet_Pt = jets[j].Pt();
                            M1Jet_Eta = jets[j].Eta();
                            M1Jet_btag = btag_scores[j];
        
                            TString type = (k < electrons.size()) ? "electron" : "muon";
        					lep_ID = obtain_lep_id(type, lep_charges[k]);
        					lep_Pt  = leps_unordered[k].Pt();
        					lep_Eta = leps_unordered[k].Eta();
                            
        					TLorentzVector reco_lep;
        					reco_lep.SetPtEtaPhiE(leps_unordered[k].Pt(), leps_unordered[k].Eta(), leps_unordered[k].Phi(), leps_unordered[k].Energy());
        					TLorentzVector reco_bJet = jets[i];
        					TLorentzVector reco_M1Jet = jets[j];
        					TLorentzVector reco_M1 = reco_M1Jet + reco_H;
        
        					M1 = reco_M1.M();
        					dR_qH = reco_M1Jet.DeltaR(reco_H);
        					dR_lb = reco_lep.DeltaR(reco_bJet);
        					dR_lt = reco_lep.DeltaR(reco_M1);
        
        	                dPhi_bMET = fabs( reco_bJet.Phi() - met_phi_ );
        				    if (dPhi_bMET > TMath::Pi()) dPhi_bMET = 2 * TMath::Pi() - dPhi_bMET;
        	                Met_Pt = MetPt();
        
                            vector<int> indices = {i, j, k};
                            indices_collector.push_back(indices);
                            ++perm;
                
                	        double score = reader_tt_v2->EvaluateMVA( "TT_lep_MVA" );
                	        if (score > best_score) {
                	        	best_score = score;
                	        	best_perm = perm;
                	        }
                	        // In the last iteration (index=NPerm-1), fill the highest score and the corresponding permutation to output.
                            bool is_the_last_permutation = (i+1 == njets_) and (j+2 == njets_) and (k+1 == nleps_);
                	        if (is_the_last_permutation) {
                                mc_mva_score_tt_v2_ = best_score;
                	        }
            		    } // End lep loop
                	} // End fcnc jet loop
                } // End b-jet loop
              } else {
                    mc_mva_score_tt_v2_ = -999;
              }
              //}}}
              // nested for loops for the MVA score, mc_mva_score_st_v2_ {{{
              do_reader_st_v2 = (njets_ >= 1) and (nleps_ >= 1);
              if(do_reader_st_v2) {
                  int perm = -1;
                  int best_perm = -1;
                  double best_score = -999;
                  vector<int> best_indices = {-1, -1};
                  vector<vector<int>> indices_collector;
        
                  // Start b-jet loop
                  for (int i=0; i<njets_; ++i) {
                      // Start W jet 1 loop
                      for (int k=0; k<nleps_; ++k) {
                              
                          bJet_Pt = jets[i].Pt();
                          bJet_Eta = jets[i].Eta();
                          bJet_btag = btag_scores[i];
        
                          TString type = (k < electrons.size()) ? "electron" : "muon";
        				  lep_ID = obtain_lep_id(type, lep_charges[k]);
        				  lep_Pt  = leps_unordered[k].Pt();
        				  lep_Eta = leps_unordered[k].Eta();
                          
                          TLorentzVector reco_lep;
               			  reco_lep.SetPtEtaPhiE(leps_unordered[k].Pt(), leps_unordered[k].Eta(), leps_unordered[k].Phi(), leps_unordered[k].Energy());
                          TLorentzVector reco_bJet = jets[i];
        
        				  dR_lb = reco_lep.DeltaR(reco_bJet);
        				  dR_lH = reco_lep.DeltaR(reco_H);
        
        	              dPhi_bMET = fabs( reco_bJet.Phi() - met_phi_ );
        				  if (dPhi_bMET > TMath::Pi()) dPhi_bMET = 2 * TMath::Pi() - dPhi_bMET;
        	              Met_Pt = MetPt();
        
                          vector<int> indices = {i, k};
                          indices_collector.push_back(indices);
                          ++perm;
              
              	          double score = reader_st_v2->EvaluateMVA( "ST_lep_MVA" );
              	          if (score > best_score) {
              	          	best_score = score;
              	          	best_perm = perm;
              	          }
              	          // In the last iteration (index=NPerm-1), fill the highest score and the corresponding permutation to output.
                          bool is_the_last_permutation = (i+1 == njets_) and (k+1 == nleps_);
              	          if (is_the_last_permutation) {
                                mc_mva_score_st_v2_ = best_score;
              	          }
                      } // End lep loop
                  } // End b-jet loop
              } else {
                    mc_mva_score_st_v2_ = -999;
              }
              //}}}
              //printf("[check] mc_mva_score_tt_v2_ = %.2f\n", mc_mva_score_tt_v2_);
              //printf("[check] mc_mva_score_st_v2_ = %.2f\n", mc_mva_score_st_v2_);
              
              float mc_mva_score_tt_v4_;
              float mc_mva_score_st_v4_;
              // nested for loops for the MVA score, mc_mva_score_tt_v4_ {{{
              do_reader_tt_v4 = (njets_ >= 2) and (nleps_ >= 1);
              if(do_reader_tt_v4) {
                int perm = -1;
                int best_perm = -1;
                double best_score = -999;
                vector<int> best_indices = {-1, -1, -1};
                vector<vector<int>> indices_collector;
        
                // Start b-jet loop
                for (int i=0; i<njets_; ++i) {
                	// Start fcnc jet loop
                	for (int j=0; j<njets_; ++j) {
                		if (j == i) continue;
                		// Start lep loop
                		for (int k=0; k<nleps_; ++k) {
        
                            bJet_Pt = jets[i].Pt();
                            bJet_Eta = jets[i].Eta();
                            bJet_btag = btag_scores[i];
                            M1Jet_Pt = jets[j].Pt();
                            M1Jet_Eta = jets[j].Eta();
                            M1Jet_btag = btag_scores[j];
        
                            TString type = (k < electrons.size()) ? "electron" : "muon";
        					lep_ID = obtain_lep_id(type, lep_charges[k]);
        					lep_Pt  = leps_unordered[k].Pt();
        					lep_Eta = leps_unordered[k].Eta();
                            
        					TLorentzVector reco_lep;
        					reco_lep.SetPtEtaPhiE(leps_unordered[k].Pt(), leps_unordered[k].Eta(), leps_unordered[k].Phi(), leps_unordered[k].Energy());
        					TLorentzVector reco_bJet = jets[i];
        					TLorentzVector reco_M1Jet = jets[j];
        					TLorentzVector reco_M1 = reco_M1Jet + reco_H;
        
        					M1 = reco_M1.M();
        					dR_qH = reco_M1Jet.DeltaR(reco_H);
        					dR_lb = reco_lep.DeltaR(reco_bJet);
        					dR_lt = reco_lep.DeltaR(reco_M1);
        
        	                dPhi_bMET = fabs( reco_bJet.Phi() - met_phi_ );
        				    if (dPhi_bMET > TMath::Pi()) dPhi_bMET = 2 * TMath::Pi() - dPhi_bMET;
        	                Met_Pt = MetPt();
        
                            vector<int> indices = {i, j, k};
                            indices_collector.push_back(indices);
                            ++perm;
                
                	        double score = reader_tt_v4->EvaluateMVA( "TT_lep_MVA" );
                	        if (score > best_score) {
                	        	best_score = score;
                	        	best_perm = perm;
                	        }
                	        // In the last iteration (index=NPerm-1), fill the highest score and the corresponding permutation to output.
                            bool is_the_last_permutation = (i+1 == njets_) and (j+2 == njets_) and (k+1 == nleps_);
                	        if (is_the_last_permutation) {
                                mc_mva_score_tt_v4_ = best_score;
                	        }
            		    } // End lep loop
                	} // End fcnc jet loop
                } // End b-jet loop
              } else {
                    mc_mva_score_tt_v4_ = -999;
              }
              //}}}
              // nested for loops for the MVA score, mc_mva_score_st_v4_ {{{
              do_reader_st_v4 = (njets_ >= 1) and (nleps_ >= 1);
              if(do_reader_st_v4) {
                  int perm = -1;
                  int best_perm = -1;
                  double best_score = -999;
                  vector<int> best_indices = {-1, -1};
                  vector<vector<int>> indices_collector;
        
                  // Start b-jet loop
                  for (int i=0; i<njets_; ++i) {
                      // Start W jet 1 loop
                      for (int k=0; k<nleps_; ++k) {
                              
                          bJet_Pt = jets[i].Pt();
                          bJet_Eta = jets[i].Eta();
                          bJet_btag = btag_scores[i];
        
                          TString type = (k < electrons.size()) ? "electron" : "muon";
        				  lep_ID = obtain_lep_id(type, lep_charges[k]);
        				  lep_Pt  = leps_unordered[k].Pt();
        				  lep_Eta = leps_unordered[k].Eta();
                          
                          TLorentzVector reco_lep;
               			  reco_lep.SetPtEtaPhiE(leps_unordered[k].Pt(), leps_unordered[k].Eta(), leps_unordered[k].Phi(), leps_unordered[k].Energy());
                          TLorentzVector reco_bJet = jets[i];
        
        				  dR_lb = reco_lep.DeltaR(reco_bJet);
        				  dR_lH = reco_lep.DeltaR(reco_H);
        
        	              dPhi_bMET = fabs( reco_bJet.Phi() - met_phi_ );
        				  if (dPhi_bMET > TMath::Pi()) dPhi_bMET = 2 * TMath::Pi() - dPhi_bMET;
        	              Met_Pt = MetPt();
        
                          vector<int> indices = {i, k};
                          indices_collector.push_back(indices);
                          ++perm;
              
              	          double score = reader_st_v4->EvaluateMVA( "ST_lep_MVA" );
              	          if (score > best_score) {
              	          	best_score = score;
              	          	best_perm = perm;
              	          }
              	          // In the last iteration (index=NPerm-1), fill the highest score and the corresponding permutation to output.
                          bool is_the_last_permutation = (i+1 == njets_) and (k+1 == nleps_);
              	          if (is_the_last_permutation) {
                                mc_mva_score_st_v4_ = best_score;
              	          }
                      } // End lep loop
                  } // End b-jet loop
              } else {
                    mc_mva_score_st_v4_ = -999;
              }
              //}}}
              //printf("[check] mc_mva_score_tt_v4_ = %.2f\n", mc_mva_score_tt_v4_);
              //printf("[check] mc_mva_score_st_v4_ = %.2f\n", mc_mva_score_st_v4_);
              //----- End of Meng-Cheng's method -----//


              //////////////////////////////
              // Start filling histograms //
              //////////////////////////////

              // General
              vProcess[processId]->fill_histogram("h" + syst_ext + "mc_mva_score_tt_v2", mc_mva_score_tt_v2_, evt_weight, vId);
              vProcess[processId]->fill_histogram("h" + syst_ext + "mc_mva_score_st_v2", mc_mva_score_st_v2_, evt_weight, vId);
              vProcess[processId]->fill_histogram("h" + syst_ext + "mc_mva_score_tt_v4", mc_mva_score_tt_v4_, evt_weight, vId);
              vProcess[processId]->fill_histogram("h" + syst_ext + "mc_mva_score_st_v4", mc_mva_score_st_v4_, evt_weight, vId);
              vProcess[processId]->fill_histogram("h" + syst_ext + "Mass", mass(), evt_weight, vId);
              vProcess[processId]->fill_histogram("h" + syst_ext + "Mass_v2", mass(), evt_weight, vId);
              //vProcess[processId]->fill_histogram("h" + syst_ext + "MassAN", mass(), evt_weight, vId);

              // Skip blinded region for MC after filling mass histogram
              if (!isSignal && !isData && blind && mass() > 120 && mass() < 130)     continue;

              if (!currentFileTitle.Contains("FCNC"))
                vProcess[processId]->fill_histogram("h" + syst_ext + "DNNScore_ttH_vs_ttGG", dnn_score_ttgg(), evt_weight, vId);

              //double dipho_mass_resolution = 0.5* pow((pow(lead_sigmaEoE(),2) + pow(sublead_sigmaEoE(),2)), 0.5);
              //vProcess[processId]->fill_histogram("h" + syst_ext + "DiphotonMassResolution", dipho_mass_resolution, evt_weight, vId);

              vProcess[processId]->fill_histogram("h" + syst_ext + "DNNScore_fcnc_tt", dnn_score_fcnc_tt(), evt_weight, vId);
              vProcess[processId]->fill_histogram("h" + syst_ext + "DNNScore_fcnc_st", dnn_score_fcnc_st(), evt_weight, vId);
              /*
              vProcess[processId]->fill_histogram("h" + syst_ext + "TopTagger_score", topTag_score(), evt_weight, vId);
              vProcess[processId]->fill_histogram("h" + syst_ext + "TopTagger_topMass", topTag_topMass(), evt_weight, vId);
              vProcess[processId]->fill_histogram("h" + syst_ext + "TopTagger_WMass", topTag_WMass(), evt_weight, vId);
              */

              double helic = helicity(lead_photon,  sublead_photon);//
              vProcess[processId]->fill_histogram("h" + syst_ext + "AbsCosHelicity", helic, evt_weight, vId);

              //vProcess[processId]->fill_histogram("h" + syst_ext + "LeadMinDr", min_dr(lead_photon, objects), evt_weight, vId);
              //vProcess[processId]->fill_histogram("h" + syst_ext + "SubleadMinDr", min_dr(sublead_photon, objects), evt_weight, vId);

              vProcess[processId]->fill_histogram("h" + syst_ext + "PhotonDeltaR", lead_photon.DeltaR(sublead_photon), evt_weight, vId);
              vProcess[processId]->fill_histogram("h" + syst_ext + "DiphotonPtOverMass", diphoton.Pt() / mass(), evt_weight, vId);

              vProcess[processId]->fill_histogram("h" + syst_ext + "PtHiggs", diphoton.Pt(), evt_weight, vId);
              //vProcess[processId]->fill_histogram("h" + syst_ext + "MinDrDiphoJet", min_dr(diphoton, jets), evt_weight, vId);
              //vProcess[processId]->fill_histogram("h" + syst_ext + "DeltaRDiphoLep", diphoton.DeltaR(leps[0]), evt_weight, vId);

              //vProcess[processId]->fill_histogram("h" + syst_ext + "PixelSeed", leadPixelSeed(), evt_weight, vId);
              //vProcess[processId]->fill_histogram("h" + syst_ext + "PixelSeed", subleadPixelSeed(), evt_weight, vId);
              //if (abs(leadEta()) < barrel_eta)
              //  vProcess[processId]->fill_histogram("h" + syst_ext + "PixelSeedEB", leadPixelSeed(), evt_weight, vId);
              //else
              //  vProcess[processId]->fill_histogram("h" + syst_ext + "PixelSeedEE", leadPixelSeed(), evt_weight, vId);
              //if (abs(subleadEta()) < barrel_eta)
              //  vProcess[processId]->fill_histogram("h" + syst_ext + "PixelSeedEB", subleadPixelSeed(), evt_weight, vId);
              //else
              //  vProcess[processId]->fill_histogram("h" + syst_ext + "PixelSeedEE", subleadPixelSeed(), evt_weight, vId);
            
              /*
              double close_mW, deltaR_dipho_W;
              if (n_ele() + n_muons() == 1) { // only for semileptonic events where we expect W->qq 
            // Hadronic W
            close_mW = closest_mW(jets, diphoton, deltaR_dipho_W);
            vProcess[processId]->fill_histogram("h" + syst_ext + "DijetClosestWMass", close_mW, evt_weight, vId);
            vProcess[processId]->fill_histogram("h" + syst_ext + "DeltaRDiphoW", deltaR_dipho_W, evt_weight, vId);

            // Hadronic top
            if (jets.size() >= 3) {
              TLorentzVector top = get_hadronic_top(jets, btag_scores_sorted);
              if (top.Pt() > 0) {
                vProcess[processId]->fill_histogram("h" + syst_ext + "TopPt", top.Pt(), evt_weight, vId);
                vProcess[processId]->fill_histogram("h" + syst_ext + "TopEta", top.Eta(), evt_weight, vId);
                vProcess[processId]->fill_histogram("h" + syst_ext + "TopMass", top.M(), evt_weight, vId);
                vProcess[processId]->fill_histogram("h" + syst_ext + "DeltaRDiphoTop", top.DeltaR(diphoton), evt_weight, vId);
              }
            }
              }
              for (int i = 0; i < jets.size(); i++) {
            for (int j = i + 1; j < jets.size(); j++) {
              TLorentzVector dijet = jets[i] + jets[j];
              vProcess[processId]->fill_histogram("h" + syst_ext + "DijetMass", dijet.M(), evt_weight, vId);
            }
              }
              */

              //vProcess[processId]->fill_histogram("h" + syst_ext + "tthMVA_RunII", tthMVA_RunII(), evt_weight, vId);
              //vProcess[processId]->fill_histogram("h" + syst_ext + "tthMVA_RunII_transf", -log(1-tthMVA_RunII()), evt_weight, vId);
              vProcess[processId]->fill_histogram("h" + syst_ext + "MVA_transf", -log(1 - mva_value), evt_weight, vId);

              if (!currentFileTitle.Contains("FCNC")) {
                  vProcess[processId]->fill_histogram("h" + syst_ext + "tthMVA_RunII", tthMVA(), evt_weight, vId);
                  vProcess[processId]->fill_histogram("h" + syst_ext + "tthMVA_RunII_transf", -log(1-tthMVA()), evt_weight, vId);
                  vProcess[processId]->fill_histogram("h" + syst_ext + "tthMVA_RunII_transf_ttZ", -log(1-tthMVA()), evt_weight, vId);
                  vProcess[processId]->fill_histogram("h" + syst_ext + "tthMVA_RunII_transf_ttZ_v2", -log(1-tthMVA_RunII()), evt_weight, vId);
                  vProcess[processId]->fill_histogram("h" + syst_ext + "tthMVA_RunII_transf_ttZ_v3", -log(1-tthMVA_RunII()), evt_weight, vId);
                  vProcess[processId]->fill_histogram("h" + syst_ext + "tthMVA_RunII_transf_ttZ_v4", -log(1-tthMVA_RunII()), evt_weight, vId);
                  vProcess[processId]->fill_histogram("h" + syst_ext + "tthMVA_RunII_transf_ttZ_v5", -log(1-tthMVA_RunII()), evt_weight, vId);
                  vProcess[processId]->fill_histogram("h" + syst_ext + "tthMVA_RunII_transf_bounded", -log(1-tthMVA_RunII())/5., evt_weight, vId);
                  vProcess[processId]->fill_histogram("h" + syst_ext + "tthMVA_RunII_transf_bounded_v2", -log(1-tthMVA_RunII())/5., evt_weight, vId);
              }
              //vProcess[processId]->fill_histogram("h" + syst_ext + "LeptonicMVA", mva_value, evt_weight, vId);
              vProcess[processId]->fill_histogram("h" + syst_ext + "Rapidity", dipho_rapidity(), evt_weight, vId);
              vProcess[processId]->fill_histogram("h" + syst_ext + "DiphotonSumPt", dipho_sumpt(), evt_weight, vId);
              vProcess[processId]->fill_histogram("h" + syst_ext + "DiphotonCosPhi", dipho_cosphi(), evt_weight, vId);

              vProcess[processId]->fill_histogram("h" + syst_ext + "NVtx", nvtx(), evt_weight, vId);
              vProcess[processId]->fill_histogram("h" + syst_ext + "Rho", rho(), evt_weight, vId);
              vProcess[processId]->fill_histogram("h" + syst_ext + "MetPt", MetPt(), evt_weight, vId);
              vProcess[processId]->fill_histogram("h" + syst_ext + "HT", get_ht(jets), evt_weight, vId);

              vProcess[processId]->fill_histogram("h" + syst_ext + "NJets", n_jets(), evt_weight, vId);
              vProcess[processId]->fill_histogram("h" + syst_ext + "NbLoose", nb_loose(), evt_weight, vId);
              vProcess[processId]->fill_histogram("h" + syst_ext + "NbMedium", nb_medium(), evt_weight, vId);
              vProcess[processId]->fill_histogram("h" + syst_ext + "NbTight", nb_tight(), evt_weight, vId);
              vProcess[processId]->fill_histogram("h" + syst_ext + "MT", mT(), evt_weight, vId);
              if (jet_pt1() != -100)      vProcess[processId]->fill_histogram("h" + syst_ext + "Jet1pT", jet_pt1(), evt_weight, vId);
              if (jet_pt2() != -100)      vProcess[processId]->fill_histogram("h" + syst_ext + "Jet2pT", jet_pt2(), evt_weight, vId);
              if (jet_pt3() != -100)      vProcess[processId]->fill_histogram("h" + syst_ext + "Jet3pT", jet_pt3(), evt_weight, vId);
              if (jet_pt4() != -100)      vProcess[processId]->fill_histogram("h" + syst_ext + "Jet4pT", jet_pt4(), evt_weight, vId);
              if (jet_pt5() != -100)      vProcess[processId]->fill_histogram("h" + syst_ext + "Jet5pT", jet_pt5(), evt_weight, vId);
              if (jet_pt6() != -100)      vProcess[processId]->fill_histogram("h" + syst_ext + "Jet6pT", jet_pt6(), evt_weight, vId);

              if (jet_pt1() != -100)      vProcess[processId]->fill_histogram("h" + syst_ext + "Jet1Eta", jet_eta1(), evt_weight, vId);
              if (jet_pt2() != -100)      vProcess[processId]->fill_histogram("h" + syst_ext + "Jet2Eta", jet_eta2(), evt_weight, vId);
              if (jet_pt3() != -100)      vProcess[processId]->fill_histogram("h" + syst_ext + "Jet3Eta", jet_eta3(), evt_weight, vId);
              if (jet_pt4() != -100)      vProcess[processId]->fill_histogram("h" + syst_ext + "Jet4Eta", jet_eta4(), evt_weight, vId);
              if (jet_pt5() != -100)      vProcess[processId]->fill_histogram("h" + syst_ext + "Jet5Eta", jet_eta5(), evt_weight, vId);
              if (jet_pt6() != -100)      vProcess[processId]->fill_histogram("h" + syst_ext + "Jet6Eta", jet_eta6(), evt_weight, vId);

              if (jet_pt1() != -100)      vProcess[processId]->fill_histogram("h" + syst_ext + "Jet1BTag", btag_scores[0], evt_weight, vId);
              if (jet_pt2() != -100)      vProcess[processId]->fill_histogram("h" + syst_ext + "Jet2BTag", btag_scores[1], evt_weight, vId);
              if (jet_pt3() != -100)      vProcess[processId]->fill_histogram("h" + syst_ext + "Jet3BTag", btag_scores[2], evt_weight, vId);
              if (jet_pt4() != -100)      vProcess[processId]->fill_histogram("h" + syst_ext + "Jet4BTag", btag_scores[3], evt_weight, vId);

              vProcess[processId]->fill_histogram("h" + syst_ext + "MaxBTagSum", max1_bsum_, evt_weight, vId);
              vProcess[processId]->fill_histogram("h" + syst_ext + "SecondMaxBTagSum", max2_bsum_, evt_weight, vId);
              vProcess[processId]->fill_histogram("h" + syst_ext + "MaxBTag", btag_scores_sorted[0].second, evt_weight, vId);
              vProcess[processId]->fill_histogram("h" + syst_ext + "SecondMaxBTag", btag_scores_sorted[1].second, evt_weight, vId);
              vProcess[processId]->fill_histogram("h" + syst_ext + "MaxCTag", max1_ctag_, evt_weight, vId);
              vProcess[processId]->fill_histogram("h" + syst_ext + "SecondMaxCTag", max2_ctag_, evt_weight, vId);
              vProcess[processId]->fill_histogram("h" + syst_ext + "MaxCvsL", max1_cvsl_, evt_weight, vId);
              vProcess[processId]->fill_histogram("h" + syst_ext + "SecondMaxCvsL", max2_cvsl_, evt_weight, vId);
              vProcess[processId]->fill_histogram("h" + syst_ext + "MaxCvsB", max1_cvsb_, evt_weight, vId);
              vProcess[processId]->fill_histogram("h" + syst_ext + "SecondMaxCvsB", max2_cvsb_, evt_weight, vId);

              double lep_pt, lep_eta;
              lep_pt = get_lep_pt(lep_eta);
              vProcess[processId]->fill_histogram("h" + syst_ext + "LeptonPt", lep_pt, evt_weight, vId);
              vProcess[processId]->fill_histogram("h" + syst_ext + "LeptonEta", lep_eta, evt_weight, vId);

              if (muon1_pt() > 0)
                vProcess[processId]->fill_histogram("h" + syst_ext + "MuonMiniIsolation", muonLeadIso() / muon1_pt(), evt_weight, vId);
              if (muon2_pt() > 0)
                vProcess[processId]->fill_histogram("h" + syst_ext + "MuonMiniIsolation", muonSubleadIso() / muon2_pt(), evt_weight, vId); 

              vProcess[processId]->fill_histogram("h" + syst_ext + "NLepLoose", n_lep_loose_, evt_weight, vId);
              vProcess[processId]->fill_histogram("h" + syst_ext + "NLepMedium", n_lep_medium_, evt_weight, vId);
              vProcess[processId]->fill_histogram("h" + syst_ext + "NLepTight", n_lep_tight_, evt_weight, vId);

              // Leading Photon
              vProcess[processId]->fill_histogram("h" + syst_ext + "PhotonLeadPt", leadPt(), evt_weight, vId);
              vProcess[processId]->fill_histogram("h" + syst_ext + "PhotonLeadEt", leadEt(), evt_weight, vId);
              vProcess[processId]->fill_histogram("h" + syst_ext + "PhotonLeadEta", leadEta(), evt_weight, vId);
              vProcess[processId]->fill_histogram("h" + syst_ext + "PhotonLeadPhi", leadPhi(), evt_weight, vId);
              vProcess[processId]->fill_histogram("h" + syst_ext + "PhotonLeadSigmaIEtaIEta", lead_sieie(), evt_weight, vId);
              vProcess[processId]->fill_histogram("h" + syst_ext + "PhotonLeadHOverE", lead_hoe(), evt_weight, vId);
              vProcess[processId]->fill_histogram("h" + syst_ext + "PhotonLeadR9", leadR9(), evt_weight, vId);
              vProcess[processId]->fill_histogram("h" + syst_ext + "PhotonLeadIDMVA", leadIDMVA(), evt_weight, vId);
              vProcess[processId]->fill_histogram("h" + syst_ext + "PhotonLeadPToM", lead_ptoM(), evt_weight, vId);
              vProcess[processId]->fill_histogram("h" + syst_ext + "PhotonLeadSigmaEOverE", lead_sigmaEoE(), evt_weight, vId);
              vProcess[processId]->fill_histogram("h" + syst_ext + "PhotonLeadPixelSeed", leadPixelSeed(), evt_weight, vId);

              /*
              if (lead_closest_gen_dR() < 999) {
                vProcess[processId]->fill_histogram("h" + syst_ext + "PhotonLeadPtGen", lead_closest_gen_Pt(), evt_weight, vId);
                vProcess[processId]->fill_histogram("h" + syst_ext + "PhotonPtRatio", leadPt() / lead_closest_gen_Pt(), evt_weight, vId);
                vProcess[processId]->fill_histogram("h" + syst_ext + "PhotonDeltaRGen", lead_closest_gen_dR(), evt_weight, vId);
              }
              */

              // Subleading Photon
              vProcess[processId]->fill_histogram("h" + syst_ext + "PhotonSubleadPt", subleadPt(), evt_weight, vId);
              vProcess[processId]->fill_histogram("h" + syst_ext + "PhotonSubleadEt", subleadEt(), evt_weight, vId);
              vProcess[processId]->fill_histogram("h" + syst_ext + "PhotonSubleadEta", subleadEta(), evt_weight, vId);
              vProcess[processId]->fill_histogram("h" + syst_ext + "PhotonSubleadPhi", subleadPhi(), evt_weight, vId);
              vProcess[processId]->fill_histogram("h" + syst_ext + "PhotonSubleadSigmaIEtaIEta", sublead_sieie(), evt_weight, vId);
              vProcess[processId]->fill_histogram("h" + syst_ext + "PhotonSubleadHOverE", sublead_hoe(), evt_weight, vId);
              vProcess[processId]->fill_histogram("h" + syst_ext + "PhotonSubleadR9", subleadR9(), evt_weight, vId);
              vProcess[processId]->fill_histogram("h" + syst_ext + "PhotonSubleadIDMVA", subleadIDMVA(), evt_weight, vId);
              vProcess[processId]->fill_histogram("h" + syst_ext + "PhotonSubleadPToM", sublead_ptoM(), evt_weight, vId);
              vProcess[processId]->fill_histogram("h" + syst_ext + "PhotonSubleadSigmaEOverE", sublead_sigmaEoE(), evt_weight, vId); 
              vProcess[processId]->fill_histogram("h" + syst_ext + "PhotonSubleadPixelSeed", subleadPixelSeed(), evt_weight, vId);

              /*
              if (sublead_closest_gen_dR() < 999) {
                vProcess[processId]->fill_histogram("h" + syst_ext + "PhotonSubleadPtGen", sublead_closest_gen_Pt(), evt_weight, vId);
                vProcess[processId]->fill_histogram("h" + syst_ext + "PhotonPtRatio", subleadPt() / sublead_closest_gen_Pt(), evt_weight, vId);
                vProcess[processId]->fill_histogram("h" + syst_ext + "PhotonDeltaRGen", sublead_closest_gen_dR(), evt_weight, vId);
              }
              */

              double maxID = maxIDMVA_;
              double minID = minIDMVA_;
              //double maxID = leadIDMVA() >= subleadIDMVA() ? leadIDMVA() : subleadIDMVA();
              //double minID = leadIDMVA() >= subleadIDMVA() ? subleadIDMVA() : leadIDMVA();

              vProcess[processId]->fill_histogram("h" + syst_ext + "PhotonMaxIDMVA", maxID, evt_weight, vId);
              vProcess[processId]->fill_histogram("h" + syst_ext + "PhotonMinIDMVA", minID, evt_weight, vId);
              vProcess[processId]->fill_histogram("h" + syst_ext + "PhotonMaxIDMVA_entries", maxID, 1, vId);
              vProcess[processId]->fill_histogram("h" + syst_ext + "PhotonMinIDMVA_entries", minID, 1, vId);
              vProcess[processId]->fill_histogram("h" + syst_ext + "PhotonMinIDMVA_coarse", minID, evt_weight, vId);
              vProcess[processId]->fill_histogram("h" + syst_ext + "PhotonMaxIDMVA_coarse", maxID, evt_weight, vId);
              vProcess[processId]->fill_histogram("h" + syst_ext + "PhotonMinIDMVA_coarse_entries", minID, 1, vId);
              vProcess[processId]->fill_histogram("h" + syst_ext + "PhotonMaxIDMVA_coarse_entries", maxID, 1, vId);

              /*
              if (njets_ >= 5)
                vProcess[processId]->fill_histogram("h" + syst_ext + "PhotonMaxIDMVA_NJets5+", maxID, evt_weight, vId);
              if (njets_ >= 7)
                vProcess[processId]->fill_histogram("h" + syst_ext + "PhotonMaxIDMVA_NJets7+", maxID, evt_weight, vId);

              if (njets_ >= 5)
                vProcess[processId]->fill_histogram("h" + syst_ext + "PhotonMinIDMVA_NJets5+", minID, evt_weight, vId);
              if (njets_ >= 7)
                vProcess[processId]->fill_histogram("h" + syst_ext + "PhotonMinIDMVA_NJets7+", minID, evt_weight, vId);


              if (nb_medium() == 0) {
            vProcess[processId]->fill_histogram("h" + syst_ext + "PhotonMinIDMVA_coarse_0b", minID, evt_weight, vId);
                vProcess[processId]->fill_histogram("h" + syst_ext + "PhotonMaxIDMVA_coarse_0b", maxID, evt_weight, vId);
              }
              vProcess[processId]->fill_histogram("h" + syst_ext + "DiphoMVA", diphoMVARes(), evt_weight, vId);

              vProcess[processId]->fill_2D_histogram("hPhotonMaxIDMVA_NJets", maxID, n_jets(), evt_weight, vId);
              vProcess[processId]->fill_2D_histogram("hPhotonMinIDMVA_NJets", minID, n_jets(), evt_weight, vId);
              vProcess[processId]->fill_2D_histogram("hPhotonMaxIDMVA_NJets_entries", maxID, n_jets(), 1, vId);
              vProcess[processId]->fill_2D_histogram("hPhotonMinIDMVA_NJets_entries", minID, n_jets(), 1, vId);

              vProcess[processId]->fill_2D_histogram("hPhotonMaxIDMVA_NTightLeps", maxID, nMuonTight() + nElecTight(), evt_weight, vId);
              vProcess[processId]->fill_2D_histogram("hPhotonMinIDMVA_NTightLeps", minID, nMuonTight() + nElecTight(), evt_weight, vId);
              vProcess[processId]->fill_2D_histogram("hPhotonMaxIDMVA_NTightLeps_entries", maxID, nMuonTight() + nElecTight(), 1, vId);
              vProcess[processId]->fill_2D_histogram("hPhotonMinIDMVA_NTightLeps_entries", minID, nMuonTight() + nElecTight(), 1, vId);

              vProcess[processId]->fill_2D_histogram("hPhotonMaxIDMVA_MinIDMVA", maxID, minID, evt_weight, vId);
             
              if (lead_photon_type() == 1) {
            vProcess[processId]->fill_histogram("h" + syst_ext + "PhotonIDMVA_prompt", leadIDMVA(), evt_weight, vId);
            vProcess[processId]->fill_histogram("h" + syst_ext + "PhotonPt_prompt", leadPt(), evt_weight, vId);
                vProcess[processId]->fill_histogram("h" + syst_ext + "PhotonEta_prompt", leadEta(), evt_weight, vId);
              }
              else if (lead_photon_type() == 2) {
                vProcess[processId]->fill_histogram("h" + syst_ext + "PhotonIDMVA_elec", leadIDMVA(), evt_weight, vId);
            vProcess[processId]->fill_histogram("h" + syst_ext + "PhotonPt_elec", leadPt(), evt_weight, vId);
                vProcess[processId]->fill_histogram("h" + syst_ext + "PhotonEta_elec", leadEta(), evt_weight, vId);
              }
              else if (lead_photon_type() == 3) {
            vProcess[processId]->fill_histogram("h" + syst_ext + "PhotonIDMVA_fake", leadIDMVA(), evt_weight, vId);
            vProcess[processId]->fill_histogram("h" + syst_ext + "PhotonPt_fake", leadPt(), evt_weight, vId);
                vProcess[processId]->fill_histogram("h" + syst_ext + "PhotonEta_fake", leadEta(), evt_weight, vId);
              }

              if (sublead_photon_type() == 1) {
                vProcess[processId]->fill_histogram("h" + syst_ext + "PhotonIDMVA_prompt", subleadIDMVA(), evt_weight, vId);
            vProcess[processId]->fill_histogram("h" + syst_ext + "PhotonPt_prompt", subleadPt(), evt_weight, vId);
                vProcess[processId]->fill_histogram("h" + syst_ext + "PhotonEta_prompt", subleadEta(), evt_weight, vId);
              }
              else if (sublead_photon_type() == 2) {
                vProcess[processId]->fill_histogram("h" + syst_ext + "PhotonIDMVA_elec", subleadIDMVA(), evt_weight, vId);
            vProcess[processId]->fill_histogram("h" + syst_ext + "PhotonPt_elec", subleadPt(), evt_weight, vId);
                vProcess[processId]->fill_histogram("h" + syst_ext + "PhotonEta_elec", subleadEta(), evt_weight, vId);
              }
              else if (sublead_photon_type() == 3) {
                vProcess[processId]->fill_histogram("h" + syst_ext + "PhotonIDMVA_fake", subleadIDMVA(), evt_weight, vId);
            vProcess[processId]->fill_histogram("h" + syst_ext + "PhotonPt_fake", subleadPt(), evt_weight, vId);
                vProcess[processId]->fill_histogram("h" + syst_ext + "PhotonEta_fake", subleadEta(), evt_weight, vId);
              }


              // Fill veto study histograms
              if (leadPassEVeto()) {
            vProcess[processId]->fill_histogram("h" + syst_ext + "PhotonIDMVA_passEVeto", leadIDMVA(), evt_weight, vId);
            vProcess[processId]->fill_histogram("h" + syst_ext + "PhotonPt_passEVeto", leadPt(), evt_weight, vId);
            vProcess[processId]->fill_histogram("h" + syst_ext + "PhotonEta_passEVeto", leadEta(), evt_weight, vId);
              }
              else {
                vProcess[processId]->fill_histogram("h" + syst_ext + "PhotonIDMVA_failEVeto", leadIDMVA(), evt_weight, vId);
            vProcess[processId]->fill_histogram("h" + syst_ext + "PhotonPt_failEVeto", leadPt(), evt_weight, vId);
            vProcess[processId]->fill_histogram("h" + syst_ext + "PhotonEta_failEVeto", leadEta(), evt_weight, vId);
              }
              if (subleadPassEVeto()) {
            vProcess[processId]->fill_histogram("h" + syst_ext + "PhotonIDMVA_passEVeto", subleadIDMVA(), evt_weight, vId);	
            vProcess[processId]->fill_histogram("h" + syst_ext + "PhotonPt_passEVeto", subleadPt(), evt_weight, vId);
                vProcess[processId]->fill_histogram("h" + syst_ext + "PhotonEta_passEVeto", subleadEta(), evt_weight, vId);
              }
              else {
            vProcess[processId]->fill_histogram("h" + syst_ext + "PhotonIDMVA_failEVeto", subleadIDMVA(), evt_weight, vId);
            vProcess[processId]->fill_histogram("h" + syst_ext + "PhotonPt_failEVeto", subleadPt(), evt_weight, vId);
                vProcess[processId]->fill_histogram("h" + syst_ext + "PhotonEta_failEVeto", subleadEta(), evt_weight, vId);
              }

              if (!leadPixelSeed()) {
                vProcess[processId]->fill_histogram("h" + syst_ext + "PhotonIDMVA_passPSV", leadIDMVA(), evt_weight, vId);
            vProcess[processId]->fill_histogram("h" + syst_ext + "PhotonPt_passPSV", leadPt(), evt_weight, vId);
                vProcess[processId]->fill_histogram("h" + syst_ext + "PhotonEta_passPSV", leadEta(), evt_weight, vId);
              }
              else {
                vProcess[processId]->fill_histogram("h" + syst_ext + "PhotonIDMVA_failPSV", leadIDMVA(), evt_weight, vId);
            vProcess[processId]->fill_histogram("h" + syst_ext + "PhotonPt_failPSV", leadPt(), evt_weight, vId);
                vProcess[processId]->fill_histogram("h" + syst_ext + "PhotonEta_failPSV", leadEta(), evt_weight, vId);
              }
              if (!subleadPixelSeed()) {
                vProcess[processId]->fill_histogram("h" + syst_ext + "PhotonIDMVA_passPSV", subleadIDMVA(), evt_weight, vId);
            vProcess[processId]->fill_histogram("h" + syst_ext + "PhotonPt_passPSV", subleadPt(), evt_weight, vId);
                vProcess[processId]->fill_histogram("h" + syst_ext + "PhotonEta_passPSV", subleadEta(), evt_weight, vId);
              }
              else {
                vProcess[processId]->fill_histogram("h" + syst_ext + "PhotonIDMVA_failPSV", subleadIDMVA(), evt_weight, vId);
            vProcess[processId]->fill_histogram("h" + syst_ext + "PhotonPt_failPSV", subleadPt(), evt_weight, vId);
                vProcess[processId]->fill_histogram("h" + syst_ext + "PhotonEta_failPSV", subleadEta(), evt_weight, vId);
              }


              if (leadPixelSeed() || subleadPixelSeed()) 
            vProcess[processId]->fill_histogram("h" + syst_ext + "PhotonMinIDMVA_failPSV", minID, evt_weight, vId);
              else
            vProcess[processId]->fill_histogram("h" + syst_ext + "PhotonMinIDMVA_passPSV", minID, evt_weight, vId);

              // pass E-veto
              if (leadPassEVeto() && subleadPassEVeto())
                vProcess[processId]->fill_histogram("h" + syst_ext + "PhotonMinIDMVA_passEVeto", minID, evt_weight, vId);
              else
            vProcess[processId]->fill_histogram("h" + syst_ext + "PhotonMinIDMVA_failEVeto", minID, evt_weight, vId);

              // pass both
              if ((!leadPixelSeed() && !subleadPixelSeed()) && (leadPassEVeto() && subleadPassEVeto()))
                vProcess[processId]->fill_histogram("h" + syst_ext + "PhotonMinIDMVA_passBothVeto", minID, evt_weight, vId);
              else
            vProcess[processId]->fill_histogram("h" + syst_ext + "PhotonMinIDMVA_failBothVeto", minID, evt_weight, vId);
              */
            }
            cout << "Deleting tree" << endl;
            delete tree;
        }
    } 
    file.Close();
  }
  if (nEventsChain != nEventsTotal) {
    cout << Form( "ERROR: number of events from files (%d) is not equal to total number of events (%d)", nEventsChain, nEventsTotal ) << endl;
  }
 
  //baby->CloseBabyNtuple();
 
  //delete rand_map;

  // Example Histograms
  f1->Write();
  f1->Close(); 

  cout << "W+gamma yield: " << w_gamma_yield << endl; 

  // return
  bmark->Stop("benchmark");
  cout << endl;
  cout << nEventsTotal << " Events Processed" << endl;
  cout << "------------------------------" << endl;
  cout << "CPU  Time: " << Form( "%.01f", bmark->GetCpuTime("benchmark")  ) << endl;
  cout << "Real Time: " << Form( "%.01f", bmark->GetRealTime("benchmark") ) << endl;
  cout << endl;
  delete bmark;
  return 0;
}
